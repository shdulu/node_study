## node 是啥

- 就是 js 的一个运行环境，可以让 js 运行在服务端,(JS 由什么组成：BOM，DOM，ECMA)，node 中不能使用 bom，dom，只有 ecmascript + 内置模块 自己写的功能和 + 第三方模块
- node 依旧是“主线程是单线程”，通常情况下 单线程 好处就是如果做的事情简单，并发量高

类似 java，php 多线程同步模型 会浪费很多线程(内存) 可以利用线程池优化，对于多线程而言，操作同一个资源会有锁的问题， 多线程感觉是一起执行，但是对于单核 cpu 而言，通过切换时间片达到同时执行（优点就是：适合 Cpu 密集型）

对于 node 而言 单线程模型 如果是 IO 密集型比较适合，通常情况下好处是异步非阻塞

> 阻塞/非阻塞指代的是调用方的状态
> 同步/异步指代的是被调用的状态

## js 特点是主线程是单线程

> Java 多线程语言，多个请求到来的时候 需要开启对应的线程来进行处理（线程池，解决防止开启大量线程，浪费内存） 超过处理个数后需要等待 （好处就是每一个都能处理复杂的逻辑） 比较适合 CPU 密集型（压缩、解密。加密） 后面的请求不用等待第一个人处理（同时操作同一个资源要上锁）

> Node-异步非阻塞 单线程的特点就是第一个处理后处理第二个（节约内存，不需要开启线程），如果第一个处理完后，会通知线程回来处理 适合 IO 密集型（异步）稍后完成了在回来处理（事件通知）底层有一个事件环的机制 文件读取写入（web 开发） Nginx (单线程模型)

## Node 的使用场景

- 服务端， 我们目前多数采用中间层（前后端分离的项目：可以解决跨域问题，可以做数据处理）
- 工具 gulp webpack vite 微前端工程化而生 node 对 js 支持友好
- 服务端渲染 ssr

## 模块化

- 为什么要有模块化（方便维护，高内聚低耦合，变量冲突问题 ）
- js 实现模块化可以采用函数来进行分割，node 中也是采用函数来进行模块划分的
- cmd(seajs) amd(require) umd(支持 amd,cmd) iife(自执行函数) commonjs(require module.exports) es6(import export) systemjs(微前端 jsonp)

前端最早可以通过单例模式解决变量冲突

```js
var obj1 = {
  function aname () {}
}
var obj2 = {
  function aname () {}
}
```

## commonJS 规范

- 每个文件都是一个模块
- 每个模块想去引用别人的模块 需要采用 require 语法
- 每个模块想被别人使用需要采用 module.exports 导出

### 内置模块

### 文件模块

### node 多进程